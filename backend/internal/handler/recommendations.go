package handler
import("context";"encoding/json";"net/http";"strconv";"time";rec"github.com/finopsmind/backend/internal/recommendations";"github.com/finopsmind/backend/internal/recommendations/rules";"github.com/go-chi/chi/v5")
type RecommendationHandler struct{engine*rec.Engine;db rec.DBQuerier}
func NewRecommendationHandler(engine*rec.Engine,db rec.DBQuerier)*RecommendationHandler{return&RecommendationHandler{engine:engine,db:db}}
func(h*RecommendationHandler)RegisterRoutes(r chi.Router){r.Route("/recommendations",func(r chi.Router){r.Get("/",h.ListRecommendations);r.Post("/generate",h.GenerateRecommendations);r.Get("/rules",h.ListRules);r.Get("/summary",h.GetSummary);r.Get("/{id}",h.GetRecommendation);r.Put("/{id}/status",h.UpdateStatus);r.Post("/{id}/dismiss",h.DismissRecommendation);r.Get("/{id}/terraform",h.GetTerraform)})}
type GenerateReq struct{AccountIDs[]string`json:"account_ids,omitempty"`;Regions[]string`json:"regions,omitempty"`;RuleIDs[]string`json:"rule_ids,omitempty"`}
func(h*RecommendationHandler)GenerateRecommendations(w http.ResponseWriter,r*http.Request){var req GenerateReq;json.NewDecoder(r.Body).Decode(&req);ctx,cancel:=context.WithTimeout(r.Context(),5*time.Minute);defer cancel();var opts[]rec.RunOption;if len(req.AccountIDs)>0{opts=append(opts,rec.WithAccounts(req.AccountIDs...))};if len(req.Regions)>0{opts=append(opts,rec.WithRegions(req.Regions...))};if len(req.RuleIDs)>0{opts=append(opts,rec.WithRules(req.RuleIDs...))};result,err:=h.engine.RunAllRules(ctx,opts...);if err!=nil{respondError(w,500,err.Error());return};var allRecs[]rec.Recommendation;for _,rr:=range result.Results{allRecs=append(allRecs,rr.Recommendations...)};h.engine.SaveRecommendations(ctx,allRecs);respondJSON(w,200,result)}
func(h*RecommendationHandler)ListRecommendations(w http.ResponseWriter,r*http.Request){recType:=r.URL.Query().Get("type");severity:=r.URL.Query().Get("severity");status:=r.URL.Query().Get("status");page,_:=strconv.Atoi(r.URL.Query().Get("page"));if page<1{page=1};limit,_:=strconv.Atoi(r.URL.Query().Get("limit"));if limit<1||limit>100{limit=20};offset:=(page-1)*limit;q:=`SELECT id,type,rule_id,resource_id,resource_type,resource_arn,account_id,region,current_state,recommended_action,estimated_savings,confidence,severity,terraform_code,resource_metadata,status,created_at,updated_at FROM recommendations WHERE 1=1`;var args[]interface{};argCount:=0;if recType!=""{argCount++;q+=" AND type = $"+strconv.Itoa(argCount);args=append(args,recType)};if severity!=""{argCount++;q+=" AND severity = $"+strconv.Itoa(argCount);args=append(args,severity)};if status!=""{argCount++;q+=" AND status = $"+strconv.Itoa(argCount);args=append(args,status)};q+=" ORDER BY estimated_savings DESC LIMIT $"+strconv.Itoa(argCount+1)+" OFFSET $"+strconv.Itoa(argCount+2);args=append(args,limit,offset);rows,err:=h.db.Query(q,args...);if err!=nil{respondError(w,500,"Query failed");return};defer rows.Close();var recs[]rec.Recommendation;for rows.Next(){var r rec.Recommendation;rows.Scan(&r.ID,&r.Type,&r.RuleID,&r.ResourceID,&r.ResourceType,&r.ResourceARN,&r.AccountID,&r.Region,&r.CurrentState,&r.RecommendedAction,&r.EstimatedSavings,&r.Confidence,&r.Severity,&r.TerraformCode,&r.ResourceMetadata,&r.Status,&r.CreatedAt,&r.UpdatedAt);recs=append(recs,r)};respondJSON(w,200,map[string]interface{}{"recommendations":recs,"pagination":map[string]int{"page":page,"limit":limit}})}
func(h*RecommendationHandler)ListRules(w http.ResponseWriter,r*http.Request){engineRules:=h.engine.GetRules();type RuleInfo struct{ID string`json:"id"`;Name string`json:"name"`;Description string`json:"description"`;ResourceTypes[]string`json:"resource_types"`};ruleInfos:=make([]RuleInfo,0,len(engineRules));for _,rule:=range engineRules{ruleInfos=append(ruleInfos,RuleInfo{ID:rule.ID(),Name:rule.Name(),Description:rule.Description(),ResourceTypes:rule.ResourceTypes()})};respondJSON(w,200,map[string]interface{}{"rules":ruleInfos,"total":len(ruleInfos),"categories":rules.GetRulesByCategory()})}
func(h*RecommendationHandler)GetSummary(w http.ResponseWriter,r*http.Request){q:=`SELECT type,severity,status,COUNT(*),SUM(estimated_savings)FROM recommendations GROUP BY type,severity,status`;rows,err:=h.db.Query(q);if err!=nil{respondError(w,500,"Query failed");return};defer rows.Close();byType:=make(map[string]map[string]interface{});var totalSavings float64;var totalCount int;for rows.Next(){var recType,severity,status string;var count int;var savings float64;rows.Scan(&recType,&severity,&status,&count,&savings);if _,ok:=byType[recType];!ok{byType[recType]=map[string]interface{}{"count":0,"savings":0.0}};byType[recType]["count"]=byType[recType]["count"].(int)+count;byType[recType]["savings"]=byType[recType]["savings"].(float64)+savings;totalSavings+=savings;totalCount+=count};respondJSON(w,200,map[string]interface{}{"total_recommendations":totalCount,"total_estimated_savings":totalSavings,"by_type":byType})}
func(h*RecommendationHandler)GetRecommendation(w http.ResponseWriter,r*http.Request){id:=chi.URLParam(r,"id");q:=`SELECT id,type,rule_id,resource_id,resource_type,resource_arn,account_id,region,current_state,recommended_action,estimated_savings,confidence,severity,terraform_code,resource_metadata,status,created_at,updated_at FROM recommendations WHERE id=$1`;var recommendation rec.Recommendation;row:=h.db.QueryRow(q,id);if err:=row.Scan(&recommendation.ID,&recommendation.Type,&recommendation.RuleID,&recommendation.ResourceID,&recommendation.ResourceType,&recommendation.ResourceARN,&recommendation.AccountID,&recommendation.Region,&recommendation.CurrentState,&recommendation.RecommendedAction,&recommendation.EstimatedSavings,&recommendation.Confidence,&recommendation.Severity,&recommendation.TerraformCode,&recommendation.ResourceMetadata,&recommendation.Status,&recommendation.CreatedAt,&recommendation.UpdatedAt);err!=nil{respondError(w,404,"Not found");return};respondJSON(w,200,recommendation)}
func(h*RecommendationHandler)UpdateStatus(w http.ResponseWriter,r*http.Request){id:=chi.URLParam(r,"id");var req struct{Status string`json:"status"`};json.NewDecoder(r.Body).Decode(&req);h.db.Query("UPDATE recommendations SET status=$1,updated_at=$2 WHERE id=$3",req.Status,time.Now(),id);respondJSON(w,200,map[string]string{"status":"updated"})}
func(h*RecommendationHandler)DismissRecommendation(w http.ResponseWriter,r*http.Request){id:=chi.URLParam(r,"id");h.db.Query("UPDATE recommendations SET status='dismissed',updated_at=$1 WHERE id=$2",time.Now(),id);respondJSON(w,200,map[string]string{"status":"dismissed"})}
func(h*RecommendationHandler)GetTerraform(w http.ResponseWriter,r*http.Request){id:=chi.URLParam(r,"id");var tf string;h.db.QueryRow("SELECT terraform_code FROM recommendations WHERE id=$1",id).Scan(&tf);w.Header().Set("Content-Type","text/plain");w.Write([]byte(tf))}
func respondJSON(w http.ResponseWriter,status int,data interface{}){w.Header().Set("Content-Type","application/json");w.WriteHeader(status);json.NewEncoder(w).Encode(data)}
func respondError(w http.ResponseWriter,status int,msg string){respondJSON(w,status,map[string]string{"error":msg})}

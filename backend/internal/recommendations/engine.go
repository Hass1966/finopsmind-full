package recommendations
import("context";"encoding/json";"fmt";"log";"sync";"time";"github.com/google/uuid")
type Engine struct{rules[]Rule;db DBQuerier;metricsStore MetricsQuerier;pricingData PricingQuerier;mu sync.RWMutex;logger*log.Logger}
func NewEngine(db DBQuerier,metrics MetricsQuerier,pricing PricingQuerier)*Engine{return&Engine{rules:make([]Rule,0),db:db,metricsStore:metrics,pricingData:pricing,logger:log.Default()}}
func(e*Engine)RegisterRule(rule Rule){e.mu.Lock();defer e.mu.Unlock();e.rules=append(e.rules,rule)}
func(e*Engine)RegisterRules(rules...Rule){for _,rule:=range rules{e.RegisterRule(rule)}}
func(e*Engine)GetRules()[]Rule{e.mu.RLock();defer e.mu.RUnlock();return append([]Rule{},e.rules...)}
func(e*Engine)GetRuleByID(id string)(Rule,bool){e.mu.RLock();defer e.mu.RUnlock();for _,rule:=range e.rules{if rule.ID()==id{return rule,true}};return nil,false}
func(e*Engine)RunAllRules(ctx context.Context,opts...RunOption)(*EngineResult,error){runOpts:=&runOptions{concurrency:4};for _,opt:=range opts{opt(runOpts)};e.mu.RLock();rulesToRun:=e.filterRules(runOpts.ruleIDs);e.mu.RUnlock();result:=&EngineResult{RunID:uuid.New().String(),StartTime:time.Now(),Results:make([]RuleResult,0,len(rulesToRun))};ruleCtx:=&RuleContext{DB:e.db,MetricsStore:e.metricsStore,PricingData:e.pricingData,Now:time.Now(),AccountIDs:runOpts.accountIDs,Regions:runOpts.regions};resultChan:=make(chan RuleResult,len(rulesToRun));sem:=make(chan struct{},runOpts.concurrency);var wg sync.WaitGroup;for _,rule:=range rulesToRun{wg.Add(1);go func(r Rule){defer wg.Done();sem<-struct{}{};defer func(){<-sem}();select{case<-ctx.Done():resultChan<-RuleResult{RuleID:r.ID(),RuleName:r.Name(),Error:ctx.Err()};return;default:};resultChan<-e.executeRule(r,ruleCtx)}(rule)};go func(){wg.Wait();close(resultChan)}();for ruleResult:=range resultChan{result.Results=append(result.Results,ruleResult);result.RulesExecuted++;if ruleResult.Error!=nil{result.RulesFailed++}else{result.TotalRecommendations+=len(ruleResult.Recommendations);for _,rec:=range ruleResult.Recommendations{result.TotalEstimatedSavings+=rec.EstimatedSavings}}};result.EndTime=time.Now();result.TotalDuration=result.EndTime.Sub(result.StartTime);return result,nil}
func(e*Engine)executeRule(rule Rule,ctx*RuleContext)RuleResult{start:=time.Now();result:=RuleResult{RuleID:rule.ID(),RuleName:rule.Name()};defer func(){if r:=recover();r!=nil{result.Error=fmt.Errorf("panic:%v",r)};result.Duration=time.Since(start)}();recs,err:=rule.Evaluate(ctx);if err!=nil{result.Error=err;return result};result.Recommendations=recs;return result}
func(e*Engine)filterRules(ruleIDs[]string)[]Rule{if len(ruleIDs)==0{return e.rules};idSet:=make(map[string]bool);for _,id:=range ruleIDs{idSet[id]=true};filtered:=make([]Rule,0);for _,rule:=range e.rules{if idSet[rule.ID()]{filtered=append(filtered,rule)}};return filtered}
func(e*Engine)SaveRecommendations(ctx context.Context,recs[]Recommendation)error{if len(recs)==0{return nil};q:=`INSERT INTO recommendations(id,type,rule_id,resource_id,resource_type,resource_arn,account_id,region,current_state,recommended_action,estimated_savings,confidence,severity,terraform_code,resource_metadata,status,created_at,updated_at)VALUES($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18)ON CONFLICT(id)DO UPDATE SET estimated_savings=EXCLUDED.estimated_savings,terraform_code=EXCLUDED.terraform_code,updated_at=EXCLUDED.updated_at`;for _,r:=range recs{m,_:=json.Marshal(r.ResourceMetadata);_,err:=e.db.Query(q,r.ID,r.Type,r.RuleID,r.ResourceID,r.ResourceType,r.ResourceARN,r.AccountID,r.Region,r.CurrentState,r.RecommendedAction,r.EstimatedSavings,r.Confidence,r.Severity,r.TerraformCode,m,"pending",time.Now(),time.Now());if err!=nil{return err}};return nil}
type runOptions struct{accountIDs,regions,ruleIDs[]string;concurrency int}
type RunOption func(*runOptions)
func WithAccounts(ids...string)RunOption{return func(o*runOptions){o.accountIDs=ids}}
func WithRegions(r...string)RunOption{return func(o*runOptions){o.regions=r}}
func WithRules(ids...string)RunOption{return func(o*runOptions){o.ruleIDs=ids}}
func WithConcurrency(n int)RunOption{return func(o*runOptions){if n>0{o.concurrency=n}}}

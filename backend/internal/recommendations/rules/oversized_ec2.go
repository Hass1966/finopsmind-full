package rules
import("fmt";"strings";rec"github.com/finopsmind/backend/internal/recommendations")
type OversizedEC2Rule struct{BaseRule;CPUThreshold float64;LookbackDays int}
func NewOversizedEC2Rule()*OversizedEC2Rule{return&OversizedEC2Rule{BaseRule:BaseRule{id:"oversized-ec2",name:"Oversized EC2 Instances",description:"EC2 using <20% CPU consistently",resourceTypes:[]string{"aws_ec2_instance"}},CPUThreshold:20.0,LookbackDays:14}}
func(r*OversizedEC2Rule)Evaluate(ctx*rec.RuleContext)([]rec.Recommendation,error){q:=fmt.Sprintf(`SELECT i.instance_id,i.instance_type,i.arn,i.account_id,i.region,COALESCE(m.avg_cpu,0),COALESCE(m.max_cpu,0)FROM ec2_instances i LEFT JOIN(SELECT resource_id,AVG(value)avg_cpu,MAX(value)max_cpu FROM cloudwatch_metrics WHERE metric_name='CPUUtilization'AND timestamp>NOW()-INTERVAL'%d days'GROUP BY resource_id)m ON i.instance_id=m.resource_id WHERE i.state='running'AND COALESCE(m.avg_cpu,0)BETWEEN 5 AND $1 AND COALESCE(m.max_cpu,0)<80`,r.LookbackDays);rows,err:=ctx.DB.Query(q,r.CPUThreshold);if err!=nil{return nil,err};defer rows.Close();var recs[]rec.Recommendation;for rows.Next(){var id,itype,arn,acct,region string;var avgCPU,maxCPU float64;if err:=rows.Scan(&id,&itype,&arn,&acct,&region,&avgCPU,&maxCPU);err!=nil{continue};newType:=suggestSmallerEC2(itype,avgCPU);if newType==itype{continue};curPrice,_:=ctx.PricingData.GetEC2HourlyPrice(itype,region);newPrice,_:=ctx.PricingData.GetEC2HourlyPrice(newType,region);if curPrice==0{curPrice=0.10};if newPrice==0{newPrice=curPrice*0.5};r:=newRec(r.id,id,"ec2_instance",arn,acct,region,rec.TypeOversized,fmt.Sprintf("%s using %.1f%% CPU",itype,avgCPU),fmt.Sprintf("Rightsize to %s",newType),(curPrice-newPrice)*hoursPerMonth,rec.ConfidenceMedium);r.TerraformCode=fmt.Sprintf("# Rightsize EC2: %s -> %s\n# instance_type = \"%s\"",id,newType,newType);recs=append(recs,r)};return recs,rows.Err()}
func suggestSmallerEC2(current string,avgCPU float64)string{sizes:=[]string{"nano","micro","small","medium","large","xlarge","2xlarge","4xlarge","8xlarge"};parts:=strings.Split(current,".");if len(parts)!=2{return current};family,curSize:=parts[0],parts[1];curIdx:=-1;for i,s:=range sizes{if s==curSize{curIdx=i;break}};if curIdx<=0{return current};steps:=1;if avgCPU<10{steps=2};newIdx:=curIdx-steps;if newIdx<0{newIdx=0};return family+"."+sizes[newIdx]}

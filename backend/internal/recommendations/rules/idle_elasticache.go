package rules
import("fmt";rec"github.com/finopsmind/backend/internal/recommendations")
type IdleElastiCacheRule struct{BaseRule;HitRateThreshold float64;LookbackDays int}
func NewIdleElastiCacheRule()*IdleElastiCacheRule{return&IdleElastiCacheRule{BaseRule:BaseRule{id:"idle-elasticache",name:"Idle ElastiCache Clusters",description:"ElastiCache with <1% cache hit rate",resourceTypes:[]string{"aws_elasticache_cluster"}},HitRateThreshold:1.0,LookbackDays:14}}
func(r*IdleElastiCacheRule)Evaluate(ctx*rec.RuleContext)([]rec.Recommendation,error){q:=fmt.Sprintf(`SELECT c.cluster_id,c.arn,c.account_id,c.region,c.engine,c.node_type,c.num_nodes,COALESCE(m.cache_hits,0),COALESCE(m.cache_misses,0),COALESCE(m.curr_conn,0)FROM elasticache_clusters c LEFT JOIN(SELECT resource_id,SUM(CASE WHEN metric_name='CacheHits'THEN value END)cache_hits,SUM(CASE WHEN metric_name='CacheMisses'THEN value END)cache_misses,AVG(CASE WHEN metric_name='CurrConnections'THEN value END)curr_conn FROM cloudwatch_metrics WHERE metric_name IN('CacheHits','CacheMisses','CurrConnections')AND timestamp>NOW()-INTERVAL'%d days'GROUP BY resource_id)m ON c.cluster_id=m.resource_id WHERE c.status='available'`,r.LookbackDays);rows,err:=ctx.DB.Query(q);if err!=nil{return nil,err};defer rows.Close();var recs[]rec.Recommendation;for rows.Next(){var clusterID,arn,acct,region,engine,nodeType string;var numNodes int;var cacheHits,cacheMisses,currConn float64;if err:=rows.Scan(&clusterID,&arn,&acct,&region,&engine,&nodeType,&numNodes,&cacheHits,&cacheMisses,&currConn);err!=nil{continue};totalReq:=cacheHits+cacheMisses;hitRate:=0.0;if totalReq>0{hitRate=(cacheHits/totalReq)*100};if hitRate>r.HitRateThreshold||(totalReq==0&&currConn>1){continue};cost:=0.10*hoursPerMonth*float64(numNodes);r:=newRec(r.id,clusterID,"elasticache_cluster",arn,acct,region,rec.TypeIdleResource,fmt.Sprintf("ElastiCache '%s' (%s, %d nodes) %.1f%% hit rate",clusterID,nodeType,numNodes,hitRate),"Delete unused cache cluster",cost,rec.ConfidenceMedium);recs=append(recs,r)};return recs,rows.Err()}

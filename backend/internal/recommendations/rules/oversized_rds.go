package rules
import("fmt";"strings";rec"github.com/finopsmind/backend/internal/recommendations")
type OversizedRDSRule struct{BaseRule;CPUThreshold float64;LookbackDays int}
func NewOversizedRDSRule()*OversizedRDSRule{return&OversizedRDSRule{BaseRule:BaseRule{id:"oversized-rds",name:"Oversized RDS Instances",description:"RDS with consistently low CPU utilization",resourceTypes:[]string{"aws_rds_instance"}},CPUThreshold:25.0,LookbackDays:14}}
func(r*OversizedRDSRule)Evaluate(ctx*rec.RuleContext)([]rec.Recommendation,error){q:=fmt.Sprintf(`SELECT d.db_instance_id,d.db_instance_class,d.engine,d.arn,d.account_id,d.region,d.multi_az,COALESCE(m.avg_cpu,0),COALESCE(m.max_cpu,0)FROM rds_instances d LEFT JOIN(SELECT resource_id,AVG(value)avg_cpu,MAX(value)max_cpu FROM cloudwatch_metrics WHERE metric_name='CPUUtilization'AND timestamp>NOW()-INTERVAL'%d days'GROUP BY resource_id)m ON d.db_instance_id=m.resource_id WHERE d.status='available'AND COALESCE(m.avg_cpu,0)BETWEEN 5 AND $1 AND COALESCE(m.max_cpu,0)<70`,r.LookbackDays);rows,err:=ctx.DB.Query(q,r.CPUThreshold);if err!=nil{return nil,err};defer rows.Close();var recs[]rec.Recommendation;for rows.Next(){var id,class,engine,arn,acct,region string;var multiAZ bool;var avgCPU,maxCPU float64;if err:=rows.Scan(&id,&class,&engine,&arn,&acct,&region,&multiAZ,&avgCPU,&maxCPU);err!=nil{continue};newClass:=suggestSmallerRDS(class,avgCPU);if newClass==class{continue};curPrice,_:=ctx.PricingData.GetRDSHourlyPrice(class,engine,region,multiAZ);newPrice,_:=ctx.PricingData.GetRDSHourlyPrice(newClass,engine,region,multiAZ);if curPrice==0{curPrice=0.20};if newPrice==0{newPrice=curPrice*0.5};r:=newRec(r.id,id,"rds_instance",arn,acct,region,rec.TypeOversized,fmt.Sprintf("%s (%s) using %.1f%% CPU",class,engine,avgCPU),fmt.Sprintf("Rightsize to %s",newClass),(curPrice-newPrice)*hoursPerMonth,rec.ConfidenceMedium);recs=append(recs,r)};return recs,rows.Err()}
func suggestSmallerRDS(current string,avgCPU float64)string{sizes:=[]string{"micro","small","medium","large","xlarge","2xlarge","4xlarge","8xlarge"};parts:=strings.Split(strings.TrimPrefix(current,"db."),".");if len(parts)!=2{return current};family,curSize:=parts[0],parts[1];curIdx:=-1;for i,s:=range sizes{if s==curSize{curIdx=i;break}};if curIdx<=0{return current};steps:=1;if avgCPU<15{steps=2};newIdx:=curIdx-steps;if newIdx<0{newIdx=0};return"db."+family+"."+sizes[newIdx]}

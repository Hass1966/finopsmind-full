package rules
import("fmt";rec"github.com/finopsmind/backend/internal/recommendations")
type IdleRDSRule struct{BaseRule;CPUThreshold float64;ConnThreshold int;LookbackDays int}
func NewIdleRDSRule()*IdleRDSRule{return&IdleRDSRule{BaseRule:BaseRule{id:"idle-rds",name:"Idle RDS Instances",description:"RDS with <5% CPU and minimal connections",resourceTypes:[]string{"aws_rds_instance"}},CPUThreshold:5.0,ConnThreshold:5,LookbackDays:7}}
func(r*IdleRDSRule)Evaluate(ctx*rec.RuleContext)([]rec.Recommendation,error){q:=fmt.Sprintf(`SELECT d.db_instance_id,d.db_instance_class,d.engine,d.arn,d.account_id,d.region,d.multi_az,COALESCE(m.avg_cpu,0),COALESCE(m.avg_conn,0)FROM rds_instances d LEFT JOIN(SELECT resource_id,AVG(CASE WHEN metric_name='CPUUtilization'THEN value END)avg_cpu,AVG(CASE WHEN metric_name='DatabaseConnections'THEN value END)avg_conn FROM cloudwatch_metrics WHERE metric_name IN('CPUUtilization','DatabaseConnections')AND timestamp>NOW()-INTERVAL'%d days'GROUP BY resource_id)m ON d.db_instance_id=m.resource_id WHERE d.status='available'AND COALESCE(m.avg_cpu,0)<$1 AND COALESCE(m.avg_conn,0)<$2`,r.LookbackDays);rows,err:=ctx.DB.Query(q,r.CPUThreshold,r.ConnThreshold);if err!=nil{return nil,err};defer rows.Close();var recs[]rec.Recommendation;for rows.Next(){var id,class,engine,arn,acct,region string;var multiAZ bool;var avgCPU,avgConn float64;if err:=rows.Scan(&id,&class,&engine,&arn,&acct,&region,&multiAZ,&avgCPU,&avgConn);err!=nil{continue};price,_:=ctx.PricingData.GetRDSHourlyPrice(class,engine,region,multiAZ);if price==0{price=0.20};r:=newRec(r.id,id,"rds_instance",arn,acct,region,rec.TypeIdleResource,fmt.Sprintf("RDS %s with %.1f%% CPU, %.0f connections",class,avgCPU,avgConn),"Stop or delete RDS instance",price*hoursPerMonth,rec.ConfidenceHigh);r.TerraformCode=fmt.Sprintf("# Stop idle RDS: %s\n# aws rds stop-db-instance --db-instance-identifier %s",id,id);recs=append(recs,r)};return recs,rows.Err()}

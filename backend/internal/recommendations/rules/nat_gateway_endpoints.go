package rules
import("fmt";rec"github.com/finopsmind/backend/internal/recommendations")
type NATGatewayEndpointsRule struct{BaseRule;MinMonthlyGBProcessed float64}
func NewNATGatewayEndpointsRule()*NATGatewayEndpointsRule{return&NATGatewayEndpointsRule{BaseRule:BaseRule{id:"nat-gateway-endpoints",name:"NAT Gateway VPC Endpoint Opportunity",description:"NAT Gateways with high S3/DynamoDB traffic",resourceTypes:[]string{"aws_nat_gateway"}},MinMonthlyGBProcessed:100.0}}
func(r*NATGatewayEndpointsRule)Evaluate(ctx*rec.RuleContext)([]rec.Recommendation,error){q:=`SELECT n.nat_gateway_id,n.vpc_id,n.account_id,n.region,COALESCE(m.s3_gb,0),COALESCE(m.dynamodb_gb,0)FROM nat_gateways n LEFT JOIN(SELECT resource_id,SUM(CASE WHEN destination_service='s3'THEN value END)/(1024*1024*1024)s3_gb,SUM(CASE WHEN destination_service='dynamodb'THEN value END)/(1024*1024*1024)dynamodb_gb FROM vpc_flow_logs WHERE timestamp>NOW()-INTERVAL'30 days'GROUP BY resource_id)m ON n.nat_gateway_id=m.resource_id WHERE n.state='available'AND(COALESCE(m.s3_gb,0)+COALESCE(m.dynamodb_gb,0))>$1`;rows,err:=ctx.DB.Query(q,r.MinMonthlyGBProcessed);if err!=nil{return nil,err};defer rows.Close();var recs[]rec.Recommendation;for rows.Next(){var natID,vpcID,acct,region string;var s3GB,dynamoDBGB float64;if err:=rows.Scan(&natID,&vpcID,&acct,&region,&s3GB,&dynamoDBGB);err!=nil{continue};savings:=(s3GB+dynamoDBGB)*0.045;r:=newRec(r.id,natID,"nat_gateway","",acct,region,rec.TypeNetworkingWaste,fmt.Sprintf("NAT processing %.1fGB S3 + %.1fGB DynamoDB",s3GB,dynamoDBGB),"Add VPC Gateway Endpoints for S3 and DynamoDB",savings,rec.ConfidenceHigh);r.TerraformCode=fmt.Sprintf("# Add VPC endpoints for %s\nresource \"aws_vpc_endpoint\" \"s3\" {\n  vpc_id = \"%s\"\n  service_name = \"com.amazonaws.%s.s3\"\n  vpc_endpoint_type = \"Gateway\"\n}",vpcID,vpcID,region);recs=append(recs,r)};return recs,rows.Err()}

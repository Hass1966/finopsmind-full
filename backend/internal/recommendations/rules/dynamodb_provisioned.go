package rules
import("fmt";rec"github.com/finopsmind/backend/internal/recommendations")
type DynamoDBProvisionedRule struct{BaseRule;UtilizationThreshold float64;LookbackDays int}
func NewDynamoDBProvisionedRule()*DynamoDBProvisionedRule{return&DynamoDBProvisionedRule{BaseRule:BaseRule{id:"dynamodb-provisioned",name:"DynamoDB Provisioned to On-Demand",description:"DynamoDB with <25% capacity utilization",resourceTypes:[]string{"aws_dynamodb_table"}},UtilizationThreshold:25.0,LookbackDays:14}}
func(r*DynamoDBProvisionedRule)Evaluate(ctx*rec.RuleContext)([]rec.Recommendation,error){q:=fmt.Sprintf(`SELECT t.table_name,t.arn,t.account_id,t.region,t.read_capacity_units,t.write_capacity_units,COALESCE(m.consumed_rcu,0),COALESCE(m.consumed_wcu,0)FROM dynamodb_tables t LEFT JOIN(SELECT resource_id,AVG(CASE WHEN metric_name='ConsumedReadCapacityUnits'THEN value END)consumed_rcu,AVG(CASE WHEN metric_name='ConsumedWriteCapacityUnits'THEN value END)consumed_wcu FROM cloudwatch_metrics WHERE metric_name IN('ConsumedReadCapacityUnits','ConsumedWriteCapacityUnits')AND timestamp>NOW()-INTERVAL'%d days'GROUP BY resource_id)m ON t.table_name=m.resource_id WHERE t.billing_mode='PROVISIONED'AND t.read_capacity_units>0`,r.LookbackDays);rows,err:=ctx.DB.Query(q);if err!=nil{return nil,err};defer rows.Close();var recs[]rec.Recommendation;for rows.Next(){var tableName,arn,acct,region string;var readCap,writeCap int;var consumedRCU,consumedWCU float64;if err:=rows.Scan(&tableName,&arn,&acct,&region,&readCap,&writeCap,&consumedRCU,&consumedWCU);err!=nil{continue};readUtil,writeUtil:=0.0,0.0;if readCap>0{readUtil=(consumedRCU/float64(readCap))*100};if writeCap>0{writeUtil=(consumedWCU/float64(writeCap))*100};avgUtil:=(readUtil+writeUtil)/2;if avgUtil>r.UtilizationThreshold{continue};provCost:=(float64(readCap)*0.00065+float64(writeCap)*0.00065)*hoursPerMonth;onDemandCost:=(consumedRCU*hoursPerMonth/1000000)*0.25+(consumedWCU*hoursPerMonth/1000000)*1.25;savings:=provCost-onDemandCost;if savings<10{continue};r:=newRec(r.id,tableName,"dynamodb_table",arn,acct,region,rec.TypeMissingOptimization,fmt.Sprintf("DynamoDB '%s' provisioned %d/%d RCU/WCU, using %.1f%%",tableName,readCap,writeCap,avgUtil),"Switch to on-demand billing",savings,rec.ConfidenceMedium);r.TerraformCode=fmt.Sprintf("# Switch to on-demand: %s\n# aws dynamodb update-table --table-name %s --billing-mode PAY_PER_REQUEST",tableName,tableName);recs=append(recs,r)};return recs,rows.Err()}
